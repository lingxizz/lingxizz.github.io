[{"title":"计算机网络","date":"2020-12-04T09:42:51.800Z","date_formatted":{"ll":"Dec 4, 2020","L":"12/04/2020","MM-DD":"12-04"},"updated":"2020-12-04T09:42:43.086Z","content":"一 OSI与TCP/IP各层的结构与功能,都有哪些协议?\n学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。\n\n结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。\n1.1 应用层\n应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。\n域名系统\n\n域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是 www.cisco.com 等。\n\nHTTP协议\n\n超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）\n\n1.2 运输层\n运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。\n运输层主要使用以下两种协议:\n\n传输控制协议 TCP（Transmission Control Protocol）–提供面向连接的，可靠的数据传输服务。\n用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。\n\nTCP 与 UDP 的对比见问题三。\n1.3 网络层\n在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。\n这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。\n这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.\n互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。\n1.4 数据链路层\n数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。\n在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。\n控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。\n1.5 物理层\n在物理层上所传送的数据单位是比特。\n物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。\n在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。\n1.6 总结一下\n上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下（图片来源于网络）。\n\n二 TCP 三次握手和四次挥手(面试常客)\n为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。\n2.1 TCP 三次握手漫画图解\n如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。\n\n简单示意图：\n\n\n客户端–发送带有 SYN 标志的数据包–一次握手–服务端\n服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端\n客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端\n\n2.2 为什么要三次握手\n三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。\n第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常\n第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常\n第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常\n所以三次握手就能确认双发收发功能都正常，缺一不可。\n2.3 第2次握手传回了ACK，为什么还要传回SYN？\n接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”\n\nSYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。\n\n2.5 为什么要四次挥手\n\n断开一个 TCP 连接则需要“四次挥手”：\n\n客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送\n服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号\n服务器-关闭与客户端的连接，发送一个FIN给客户端\n客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1\n\n任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。\n举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。\n上面讲的比较概括，推荐一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891\n三 TCP,UDP 协议的区别\n\nUDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等\nTCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。\n四 TCP 协议如何保证可靠传输\n\n应用数据被分割成 TCP 认为最适合发送的数据块。\nTCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。\n校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。\nTCP 的接收端会丢弃重复的数据。\n流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）\n拥塞控制： 当网络拥塞时，减少数据的发送。\nARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。\n超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。\n\n4.1 ARQ协议\n自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。\n停止等待ARQ协议\n\n停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；\n在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；\n\n优点： 简单\n缺点： 信道利用率低，等待时间长\n1) 无差错情况:\n发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。\n2) 出现差错情况（超时重传）:\n停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。\n3) 确认丢失和确认迟到\n\n确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。\n确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。\n\n连续ARQ协议\n连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。\n缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。\n4.2 滑动窗口和流量控制\nTCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n4.3 拥塞控制\n在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。\n为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。\nTCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。\n\n慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。\n拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.\n快重传与快恢复：\n在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。\n\n五  在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)\n百度好像最喜欢问这个问题。\n\n打开一个网页，整个过程会使用哪些协议\n\n图解（图片来源：《图解HTTP》）：\n\n总体来说分为以下几个过程:\n\nDNS解析\nTCP连接\n发送HTTP请求\n服务器处理请求并返回HTTP报文\n浏览器解析渲染页面\n连接结束\n\n具体可以参考下面这篇文章：\n\nhttps://segmentfault.com/a/1190000006879700\n\n六 状态码\n\n七 各种协议与HTTP协议之间的关系\n一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。\n图片来源：《图解HTTP》\n\n八  HTTP长连接,短连接\n在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。\n而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：\n1Connection:keep-alive\n在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nHTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。\n—— 《HTTP长连接、短连接究竟是什么？》\n九 HTTP是不保存状态的协议,如何保存用户状态?\nHTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP  协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。\n在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。\nCookie 被禁用怎么办?\n最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。\n\n十 Cookie的作用是什么?和Session有什么区别？\nCookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。\nCookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。\nCookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。\nCookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。\n十一 HTTP 1.0和HTTP 1.1的主要区别是什么?\n\n这部分回答引用这篇文章 https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A? 的一些内容。\n\nHTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：\n\n长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。\n错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n十二 URI和URL的区别是什么?\n\nURI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\nURL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\n\nURI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。\n十三 HTTP 和 HTTPS 的区别？\n\n端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。\n安全性和资源消耗： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。\n\n对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；\n非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。\n\n\n\n建议\n非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。\n参考\n\nhttps://blog.csdn.net/qq_16209077/article/details/52718250\nhttps://blog.csdn.net/zixiaomuwu/article/details/60965466\nhttps://blog.csdn.net/turn__back/article/details/73743641\nhttps://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?\n\n","plink":"http://yoursite.com/2020/12/04/计算机网络/"},{"title":"Spring","date":"2020-12-04T09:42:49.854Z","date_formatted":{"ll":"Dec 4, 2020","L":"12/04/2020","MM-DD":"12-04"},"updated":"2020-11-28T02:44:42.072Z","content":"\n\nTable of Contents  generated with DocToc\n\n基本\n\nClassPathXmlApplicationContext\n\n构造器\n设置配置文件路径\n\nEnvironment接口\n\nProfile\nProperty\n\n\nEnvironment构造器\n\nPropertySources接口\nPropertySource接口\n\n\n路径Placeholder处理\n\nPropertyResolver接口\n解析\n\n\n\n\n\n\nrefresh\n\nprepareRefresh\n\n属性校验\n\n\nBeanFactory创建\n\nBeanFactory接口\nBeanFactory定制\nBean加载\n\nEntityResolver\nBeanDefinitionReader\n路径解析(Ant)\n配置文件加载\nBean解析\n\n\n默认命名空间解析\n\nimport\nalias\nbean\n\nid &amp; name处理\nbeanName生成\nbean解析\nBean装饰\nBean注册\nBeanDefiniton数据结构\n\n\nbeans\n\n\n其它命名空间解析\n\nNamespaceHandler继承体系\ninit\nBeanFactory数据结构\n\n\n\n\nprepareBeanFactory\n\nBeanExpressionResolver\nPropertyEditorRegistrar\n环境注入\n依赖解析忽略\nbean伪装\nLoadTimeWeaver\n注册环境\n\n\npostProcessBeanFactory\ninvokeBeanFactoryPostProcessors\nBeanPostProcessor注册\nMessageSource\n事件驱动\n\n事件\n发布者\n\nApplicationEventPublisher\nApplicationEventMulticaster\n\n\n监听器\n初始化\n事件发布\n\n监听器获取\n同步/异步\n\n全局\n注解\n\n\n\n\n\n\nonRefresh\nApplicationListener注册\nsingleton初始化\n\nConversionService\nStringValueResolver\nLoadTimeWeaverAware\n初始化\n\n\n\n\n\n\ngetBean\n\nbeanName转化\n手动注册bean检测\n检查父容器\n依赖初始化\nSingleton初始化\n\ngetSingleton方法\n\n是否存在\nbean创建\n\nlookup-method检测\nInstantiationAwareBeanPostProcessor触发\ndoCreateBean\n\n创建(createBeanInstance)\nMergedBeanDefinitionPostProcessor\n属性解析\n属性设置\n初始化\n\n\n\n\n\n\ngetObjectForBeanInstance\n\n\nPrototype初始化\n\nbeforePrototypeCreation\ncreateBean\nafterPrototypeCreation\n总结\n\n\n其它Scope初始化\n\n\n\n\n基本\n本部分从最基本的Spring开始。配置文件:\n1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;    &lt;beans&gt;        &lt;bean class=\"base.SimpleBean\"&gt;&lt;/bean&gt;&lt;/beans&gt;\n启动代码:\n123456public static void main(String[] args) &#123;    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\");    SimpleBean bean = context.getBean(SimpleBean.class);    bean.send();    context.close();&#125;\nSimpleBean:\n12345public class SimpleBean &#123;    public void send() &#123;        System.out.println(\"I am send method from SimpleBean!\");    &#125;&#125;\nClassPathXmlApplicationContext\n整个继承体系如下:\n\nResourceLoader代表了加载资源的一种方式，正是策略模式的实现。\n构造器源码:\n123456789public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext \t         parent) &#123;    //null    super(parent);    setConfigLocations(configLocations);    //默认true    if (refresh) &#123;        refresh();    &#125;&#125;\n构造器\n首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext:\n1234567public AbstractApplicationContext(ApplicationContext parent) &#123;    this();    setParent(parent);&#125;public AbstractApplicationContext() &#123;    this.resourcePatternResolver = getResourcePatternResolver();&#125;\ngetResourcePatternResolver:\n123protected ResourcePatternResolver getResourcePatternResolver() &#123;    return new PathMatchingResourcePatternResolver(this);&#125;\nPathMatchingResourcePatternResolver支持Ant风格的路径解析。\n设置配置文件路径\n即AbstractRefreshableConfigApplicationContext.setConfigLocations:\n1234567891011public void setConfigLocations(String... locations) &#123;    if (locations != null) &#123;        Assert.noNullElements(locations, \"Config locations must not be null\");        this.configLocations = new String[locations.length];        for (int i = 0; i &lt; locations.length; i++) &#123;            this.configLocations[i] = resolvePath(locations[i]).trim();        &#125;    &#125; else &#123;        this.configLocations = null;    &#125;&#125;\nresolvePath:\n123protected String resolvePath(String path) &#123;    return getEnvironment().resolveRequiredPlaceholders(path);&#125;\n此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);那么classpath:就是需要被解析的。\ngetEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment:\n123protected ConfigurableEnvironment createEnvironment() &#123;    return new StandardEnvironment();&#125;\nEnvironment接口\n继承体系:\n\nEnvironmen接口**代表了当前应用所处的环境。**从此接口的方法可以看出，其主要和profile、Property相关。\nProfile\nSpring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。**Spring容器管理的所有bean都是和一个profile绑定在一起的。**使用了Profile的配置文件示例:\n123456789&lt;beans profile=\"develop\"&gt;      &lt;context:property-placeholder location=\"classpath*:jdbc-develop.properties\"/&gt;  &lt;/beans&gt;  &lt;beans profile=\"production\"&gt;      &lt;context:property-placeholder location=\"classpath*:jdbc-production.properties\"/&gt;  &lt;/beans&gt;  &lt;beans profile=\"test\"&gt;      &lt;context:property-placeholder location=\"classpath*:jdbc-test.properties\"/&gt;  &lt;/beans&gt;\n在启动代码中可以用如下代码设置活跃(当前使用的)Profile:\n1context.getEnvironment().setActiveProfiles(\"dev\");\n当然使用的方式还有很多(比如注解)，参考:\nspring3.1 profile 配置不同的环境\nSpring Profiles example\nProperty\n这里的Property指的是程序运行时的一些参数，引用注释:\n\n\nproperties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on.\n\n\nEnvironment构造器\n1234private final MutablePropertySources propertySources = new MutablePropertySources(this.logger);public AbstractEnvironment() &#123;    customizePropertySources(this.propertySources);&#125;\nPropertySources接口\n继承体系:\n\n此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。\nStandardEnvironment.customizePropertySources:\n1234567891011/** System environment property source name: &#123;@value&#125; */public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = \"systemEnvironment\";/** JVM system properties property source name: &#123;@value&#125; */public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = \"systemProperties\";@Overrideprotected void customizePropertySources(MutablePropertySources propertySources) &#123;    propertySources.addLast(new MapPropertySource        (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));    propertySources.addLast(new SystemEnvironmentPropertySource        (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));&#125;\nPropertySource接口\nPropertySource接口代表了键值对的Property来源。继承体系：\n\nAbstractEnvironment.getSystemProperties:\n123456789101112131415161718192021222324@Overridepublic Map&lt;String, Object&gt; getSystemProperties() &#123;    try &#123;        return (Map) System.getProperties();    &#125;    catch (AccessControlException ex) &#123;        return (Map) new ReadOnlySystemAttributesMap() &#123;            @Override            protected String getSystemAttribute(String attributeName) &#123;                try &#123;                    return System.getProperty(attributeName);                &#125;                catch (AccessControlException ex) &#123;                    if (logger.isInfoEnabled()) &#123;                        logger.info(format(\"Caught AccessControlException when accessing system \" +                                \"property [%s]; its value will be returned [null]. Reason: %s\",                                attributeName, ex.getMessage()));                    &#125;                    return null;                &#125;            &#125;        &#125;;    &#125;&#125;\n这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。\ngetSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。\n路径Placeholder处理\nAbstractEnvironment.resolveRequiredPlaceholders:\n12345@Overridepublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException &#123;    //text即配置文件路径，比如classpath:config.xml    return this.propertyResolver.resolveRequiredPlaceholders(text);&#125;\npropertyResolver是一个PropertySourcesPropertyResolver对象:\n12private final ConfigurablePropertyResolver propertyResolver =            new PropertySourcesPropertyResolver(this.propertySources);\nPropertyResolver接口\nPropertyResolver继承体系(排除Environment分支):\n\n此接口正是用来解析PropertyResource。\n解析\nAbstractPropertyResolver.resolveRequiredPlaceholders:\n1234567@Overridepublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException &#123;    if (this.strictHelper == null) &#123;        this.strictHelper = createPlaceholderHelper(false);    &#125;    return doResolvePlaceholders(text, this.strictHelper);&#125;\n12345private PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) &#123;    //三个参数分别是$&#123;, &#125;, :    return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix,        this.valueSeparator, ignoreUnresolvablePlaceholders);&#125;\ndoResolvePlaceholders：\n123456789private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) &#123;    //PlaceholderResolver接口依然是策略模式的体现    return helper.replacePlaceholders(text, new PropertyPlaceholderHelper.PlaceholderResolver() &#123;        @Override        public String resolvePlaceholder(String placeholderName) &#123;            return getPropertyAsRawString(placeholderName);        &#125;    &#125;);&#125;\n其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写:\n123System.setProperty(\"spring\", \"classpath\");ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"$&#123;spring&#125;:config.xml\");SimpleBean bean = context.getBean(SimpleBean.class);\n这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty:\n12345678910111213@Overrideprotected String getPropertyAsRawString(String key) &#123;    return getProperty(key, String.class, false);&#125;protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) &#123;    if (this.propertySources != null) &#123;        for (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123;            Object value = propertySource.getProperty(key);            return value;        &#125;    &#125;    return null;&#125;\n很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。\n注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。\nrefresh\nSpring bean解析就在此方法，所以单独提出来。\nAbstractApplicationContext.refresh:\n123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic void refresh() throws BeansException, IllegalStateException &#123;    synchronized (this.startupShutdownMonitor) &#123;        // Prepare this context for refreshing.        prepareRefresh();        // Tell the subclass to refresh the internal bean factory.        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // Prepare the bean factory for use in this context.        prepareBeanFactory(beanFactory);        try &#123;            // Allows post-processing of the bean factory in context subclasses.            postProcessBeanFactory(beanFactory);            // Invoke factory processors registered as beans in the context.            invokeBeanFactoryPostProcessors(beanFactory);            // Register bean processors that intercept bean creation.            registerBeanPostProcessors(beanFactory);            // Initialize message source for this context.            initMessageSource();            // Initialize event multicaster for this context.            initApplicationEventMulticaster();            // Initialize other special beans in specific context subclasses.            onRefresh();            // Check for listener beans and register them.            registerListeners();            // Instantiate all remaining (non-lazy-init) singletons.            finishBeanFactoryInitialization(beanFactory);            // Last step: publish corresponding event.            finishRefresh();        &#125; catch (BeansException ex) &#123;            // Destroy already created singletons to avoid dangling resources.            destroyBeans();            // Reset 'active' flag.            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        &#125; finally &#123;            // Reset common introspection caches in Spring's core, since we            // might not ever need metadata for singleton beans anymore...            resetCommonCaches();        &#125;    &#125;&#125;\nprepareRefresh\n1234567891011121314protected void prepareRefresh() &#123;    this.startupDate = System.currentTimeMillis();    this.closed.set(false);    this.active.set(true);    // Initialize any placeholder property sources in the context environment    //空实现    initPropertySources();    // Validate that all properties marked as required are resolvable    // see ConfigurablePropertyResolver#setRequiredProperties    getEnvironment().validateRequiredProperties();    // Allow for the collection of early ApplicationEvents,    // to be published once the multicaster is available...    this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();&#125;\n属性校验\nAbstractEnvironment.validateRequiredProperties:\n1234@Overridepublic void validateRequiredProperties() throws MissingRequiredPropertiesException &#123;    this.propertyResolver.validateRequiredProperties();&#125;\nAbstractPropertyResolver.validateRequiredProperties:\n123456789101112@Overridepublic void validateRequiredProperties() &#123;    MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();    for (String key : this.requiredProperties) &#123;        if (this.getProperty(key) == null) &#123;            ex.addMissingRequiredProperty(key);        &#125;    &#125;    if (!ex.getMissingRequiredProperties().isEmpty()) &#123;        throw ex;    &#125;&#125;\nrequiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。\nBeanFactory创建\n由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory:\n12345678910111213141516@Overrideprotected final void refreshBeanFactory() throws BeansException &#123;    //如果已经存在，那么销毁之前的    if (hasBeanFactory()) &#123;        destroyBeans();        closeBeanFactory();    &#125;    //创建了一个DefaultListableBeanFactory对象    DefaultListableBeanFactory beanFactory = createBeanFactory();    beanFactory.setSerializationId(getId());    customizeBeanFactory(beanFactory);    loadBeanDefinitions(beanFactory);    synchronized (this.beanFactoryMonitor) &#123;        this.beanFactory = beanFactory;    &#125;&#125;\nBeanFactory接口\n此接口实际上就是Bean容器，其继承体系:\n\nBeanFactory定制\nAbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现:\n12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;    if (this.allowBeanDefinitionOverriding != null) &#123;        //默认false，不允许覆盖        beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);    &#125;    if (this.allowCircularReferences != null) &#123;        //默认false，不允许循环引用        beanFactory.setAllowCircularReferences(this.allowCircularReferences);    &#125;&#125;\nBean加载\nAbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了:\n123456789101112131415@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) &#123;    // Create a new XmlBeanDefinitionReader for the given BeanFactory.    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);    // Configure the bean definition reader with this context's    // resource loading environment.    beanDefinitionReader.setEnvironment(this.getEnvironment());    beanDefinitionReader.setResourceLoader(this);    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));    // Allow a subclass to provide custom initialization of the reader,    // then proceed with actually loading the bean definitions.    //默认空实现    initBeanDefinitionReader(beanDefinitionReader);    loadBeanDefinitions(beanDefinitionReader);&#125;\nEntityResolver\n此处只说明用到的部分继承体系:\n\nEntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。\nBeanDefinitionReader\n继承体系:\n\n路径解析(Ant)\n1234567891011protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) &#123;    Resource[] configResources = getConfigResources();    if (configResources != null) &#123;        reader.loadBeanDefinitions(configResources);    &#125;    String[] configLocations = getConfigLocations();    //here    if (configLocations != null) &#123;        reader.loadBeanDefinitions(configLocations);    &#125;&#125;\nAbstractBeanDefinitionReader.loadBeanDefinitions:\n123456789@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException &#123;    Assert.notNull(locations, \"Location array must not be null\");    int counter = 0;    for (String location : locations) &#123;        counter += loadBeanDefinitions(location);    &#125;    return counter;&#125;\n之后调用:\n12345678910111213141516171819202122232425262728293031//第二个参数为空public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) &#123;    ResourceLoader resourceLoader = getResourceLoader();    //参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口    if (resourceLoader instanceof ResourcePatternResolver) &#123;        // Resource pattern matching available.        try &#123;            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);            int loadCount = loadBeanDefinitions(resources);            if (actualResources != null) &#123;                for (Resource resource : resources) &#123;                    actualResources.add(resource);                &#125;            &#125;            return loadCount;        &#125;        catch (IOException ex) &#123;            throw new BeanDefinitionStoreException(                    \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);        &#125;    &#125;    else &#123;        // Can only load single resources by absolute URL.        Resource resource = resourceLoader.getResource(location);        int loadCount = loadBeanDefinitions(resource);        if (actualResources != null) &#123;            actualResources.add(resource);        &#125;        return loadCount;    &#125;&#125;\ngetResource的实现在AbstractApplicationContext：\n12345@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123;    //构造器中初始化，PathMatchingResourcePatternResolver对象    return this.resourcePatternResolver.getResources(locationPattern);&#125;\nPathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。\n123456789101112131415161718192021222324252627282930@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123;    Assert.notNull(locationPattern, \"Location pattern must not be null\");    //classpath:    if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;        // a class path resource (multiple resources for same name possible)        //matcher是一个AntPathMatcher对象        if (getPathMatcher().isPattern(locationPattern            .substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;            // a class path resource pattern            return findPathMatchingResources(locationPattern);        &#125; else &#123;            // all class path resources with the given name            return findAllClassPathResources(locationPattern                .substring(CLASSPATH_ALL_URL_PREFIX.length()));        &#125;    &#125; else &#123;        // Only look for a pattern after a prefix here        // (to not get fooled by a pattern symbol in a strange prefix).        int prefixEnd = locationPattern.indexOf(\":\") + 1;        if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;            // a file pattern            return findPathMatchingResources(locationPattern);        &#125;        else &#123;            // a single resource with the given name            return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;        &#125;    &#125;&#125;\nisPattern:\n1234@Overridepublic boolean isPattern(String path) &#123;    return (path.indexOf('*') != -1 || path.indexOf('?') != -1);&#125;\n可以看出配置文件路径是支持ant风格的，也就是可以这么写:\n1new ClassPathXmlApplicationContext(\"con*.xml\");\n具体怎么解析ant风格的就不写了。\n配置文件加载\n入口方法在AbstractBeanDefinitionReader的217行:\n1234//加载Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);//解析int loadCount = loadBeanDefinitions(resources);\n最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法:\n1234@Overridepublic int loadBeanDefinitions(Resource resource) &#123;    return loadBeanDefinitions(new EncodedResource(resource));&#125;\nResource是代表一种资源的接口，其类图:\n\nEncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。\n之后关键的源码只有两行:\n12345public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;    InputStream inputStream = encodedResource.getResource().getInputStream();    InputSource inputSource = new InputSource(inputStream);    return doLoadBeanDefinitions(inputSource, encodedResource.getResource());&#125;\nInputSource是org.xml.sax的类。\ndoLoadBeanDefinitions：\n1234protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) &#123;    Document doc = doLoadDocument(inputSource, resource);    return registerBeanDefinitions(doc, resource);&#125;\ndoLoadDocument:\n1234protected Document doLoadDocument(InputSource inputSource, Resource resource) &#123;    return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,        getValidationModeForResource(resource), isNamespaceAware());&#125;\ndocumentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。\n校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。\nNamespaceAware默认false，因为默认配置了校验为true。\nDefaultDocumentLoader.loadDocument:\n12345678@Overridepublic Document loadDocument(InputSource inputSource, EntityResolver entityResolver,    ErrorHandler errorHandler, int validationMode, boolean namespaceAware) &#123;    //这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);    return builder.parse(inputSource);&#125;\ncreateDocumentBuilderFactory比较有意思:\n12345678910111213141516protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware&#123;    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();    factory.setNamespaceAware(namespaceAware);    if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;        //此方法设为true仅对dtd有效，xsd(schema)无效        factory.setValidating(true);        if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;            // Enforce namespace aware for XSD...             //开启xsd(schema)支持            factory.setNamespaceAware(true);             //这个也是Java支持Schema的套路，可以问度娘            factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);        &#125;    &#125;    return factory;&#125;\nBean解析\nXmlBeanDefinitionReader.registerBeanDefinitions:\n123456public int registerBeanDefinitions(Document doc, Resource resource) &#123;    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();    int countBefore = getRegistry().getBeanDefinitionCount();    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));    return getRegistry().getBeanDefinitionCount() - countBefore;&#125;\ncreateBeanDefinitionDocumentReader:\n12345protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123;    return BeanDefinitionDocumentReader.class.cast      //反射      (BeanUtils.instantiateClass(this.documentReaderClass));&#125;\ndocumentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。\n注意cast方法，代替了强转。\ncreateReaderContext：\n1234public XmlReaderContext createReaderContext(Resource resource) &#123;    return new XmlReaderContext(resource, this.problemReporter, this.eventListener,        this.sourceExtractor, this, getNamespaceHandlerResolver());&#125;\nproblemReporter是一个FailFastProblemReporter对象。\neventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。\nsourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。\ngetNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。\nXmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。\nDefaultBeanDefinitionDocumentReader.registerBeanDefinitions:\n123456@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;    this.readerContext = readerContext;    Element root = doc.getDocumentElement();    doRegisterBeanDefinitions(root);&#125;\ndoRegisterBeanDefinitions:\n12345678910111213141516171819202122protected void doRegisterBeanDefinitions(Element root) &#123;    BeanDefinitionParserDelegate parent = this.delegate;    this.delegate = createDelegate(getReaderContext(), root, parent);    //默认的命名空间即    //http://www.springframework.org/schema/beans    if (this.delegate.isDefaultNamespace(root)) &#123;        //检查profile属性        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);        if (StringUtils.hasText(profileSpec)) &#123;            //profile属性可以以,分割            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;                return;            &#125;        &#125;    &#125;    preProcessXml(root);    parseBeanDefinitions(root, this.delegate);    postProcessXml(root);    this.delegate = parent;&#125;\ndelegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的:\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;    &lt;beans&gt;        &lt;bean class=\"base.SimpleBean\"&gt;&lt;/bean&gt;    &lt;beans&gt;        &lt;bean class=\"java.lang.Object\"&gt;&lt;/bean&gt;    &lt;/beans&gt;&lt;/beans&gt;\nxml(schema)的命名空间其实类似于java的报名，命名空间采用URL，比如Spring的是这样:\n12&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;    &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"&gt;&lt;/beans&gt;\nxmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于http://www.springframework.org/schema/beans:bean，可以有效的防止命名冲突。命名空间可以通过规范定义的org.w3c.dom.Node.getNamespaceURI方法获得。\n注意一下profile的检查, AbstractEnvironment.acceptsProfiles:\n1234567891011121314@Overridepublic boolean acceptsProfiles(String... profiles) &#123;    Assert.notEmpty(profiles, \"Must specify at least one profile\");    for (String profile : profiles) &#123;        if (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(0) == '!') &#123;            if (!isProfileActive(profile.substring(1))) &#123;                return true;            &#125;        &#125; else if (isProfileActive(profile)) &#123;            return true;        &#125;    &#125;    return false;&#125;\n原理很简单，注意从源码可以看出，profile属性支持!取反。\npreProcessXml方法是个空实现，供子类去覆盖，目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会, 想的真周到。\nDefaultBeanDefinitionDocumentReader.parseBeanDefinitions：\n123456789101112131415161718protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;    if (delegate.isDefaultNamespace(root)) &#123;        NodeList nl = root.getChildNodes();        for (int i = 0; i &lt; nl.getLength(); i++) &#123;            Node node = nl.item(i);            if (node instanceof Element) &#123;                Element ele = (Element) node;                if (delegate.isDefaultNamespace(ele)) &#123;                    parseDefaultElement(ele, delegate);                &#125; else &#123;                    delegate.parseCustomElement(ele);                &#125;            &#125;        &#125;    &#125; else &#123;        delegate.parseCustomElement(root);    &#125;&#125;\n可见，对于非默认命名空间的元素交由delegate处理。\n默认命名空间解析\n即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement:\n12345678910111213141516private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;    //\"import\"    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;        importBeanDefinitionResource(ele);    &#125;    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;        processAliasRegistration(ele);    &#125;    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;        processBeanDefinition(ele, delegate);    &#125;    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;        // recurse        doRegisterBeanDefinitions(ele);    &#125;&#125;\nimport\n写法示例:\n12&lt;import resource=\"CTIContext.xml\" /&gt;&lt;import resource=\"customerContext.xml\" /&gt;\nimportBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。\nalias\n加入有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义:\n1&lt;alias name=\"componentA-dataSource\" alias=\"componentB-dataSource\"/&gt;\nprocessAliasRegistration核心源码:\n123456protected void processAliasRegistration(Element ele) &#123;    String name = ele.getAttribute(NAME_ATTRIBUTE);    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);    getReaderContext().getRegistry().registerAlias(name, alias);    getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));&#125;\n从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry:\n12345678910111213141516171819202122232425@Overridepublic void registerAlias(String name, String alias) &#123;    Assert.hasText(name, \"'name' must not be empty\");    Assert.hasText(alias, \"'alias' must not be empty\");    //名字和别名一样    if (alias.equals(name)) &#123;        //ConcurrentHashMap        this.aliasMap.remove(alias);    &#125; else &#123;        String registeredName = this.aliasMap.get(alias);        if (registeredName != null) &#123;            if (registeredName.equals(name)) &#123;                // An existing alias - no need to re-register                return;            &#125;            if (!allowAliasOverriding()) &#123;                throw new IllegalStateException                    (\"Cannot register alias '\" + alias + \"' for name '\" +                    name + \"': It is already registered for name '\" + registeredName + \"'.\");            &#125;        &#125;        checkForAliasCircle(name, alias);        this.aliasMap.put(alias, name);    &#125;&#125;\n所以别名关系的保存使用Map完成，key为别名，value为本来的名字。\nbean\nbean节点是Spring最最常见的节点了。\nDefaultBeanDefinitionDocumentReader.processBeanDefinition:\n1234567891011121314151617protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    if (bdHolder != null) &#123;        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);        try &#123;            // Register the final decorated instance.            BeanDefinitionReaderUtils.registerBeanDefinition                (bdHolder, getReaderContext().getRegistry());        &#125;        catch (BeanDefinitionStoreException ex) &#123;            getReaderContext().error(\"Failed to register bean definition with name '\" +                    bdHolder.getBeanName() + \"'\", ele, ex);        &#125;        // Send registration event.        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));    &#125;&#125;\nid &amp; name处理\n最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。\n首先获取到id和name属性，name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做。\n1234567891011121314151617181920String id = ele.getAttribute(ID_ATTRIBUTE);String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();if (StringUtils.hasLength(nameAttr)) &#123;    //按,分隔    String[] nameArr = StringUtils.tokenizeToStringArray        (nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);    aliases.addAll(Arrays.asList(nameArr));&#125;String beanName = id;if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;    //name的第一个值作为id    beanName = aliases.remove(0);&#125;//默认nullif (containingBean == null) &#123;    //校验id是否已重复，如果重复直接抛异常    //校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set    checkNameUniqueness(beanName, aliases, ele);&#125;\nbeanName生成\n如果name和id属性都没有指定，那么Spring会自己生成一个, BeanDefinitionParserDelegate.parseBeanDefinitionElement:\n123beanName = this.readerContext.generateBeanName(beanDefinition);String beanClassName = beanDefinition.getBeanClassName();aliases.add(beanClassName);\n可见，Spring同时会把类名作为其别名。\n最终调用的是BeanDefinitionReaderUtils.generateBeanName:\n12345678910111213141516171819202122232425262728public static String generateBeanName(        BeanDefinition definition, BeanDefinitionRegistry registry, boolean isInnerBean) &#123;    String generatedBeanName = definition.getBeanClassName();    if (generatedBeanName == null) &#123;        if (definition.getParentName() != null) &#123;            generatedBeanName = definition.getParentName() + \"$child\";             //工厂方法产生的bean        &#125; else if (definition.getFactoryBeanName() != null) &#123;            generatedBeanName = definition.getFactoryBeanName() + \"$created\";        &#125;    &#125;    String id = generatedBeanName;    if (isInnerBean) &#123;        // Inner bean: generate identity hashcode suffix.        id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR +             ObjectUtils.getIdentityHexString(definition);    &#125; else &#123;        // Top-level bean: use plain class name.        // Increase counter until the id is unique.        int counter = -1;         //用类名#自增的数字命名        while (counter == -1 || registry.containsBeanDefinition(id)) &#123;            counter++;            id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter;        &#125;    &#125;    return id;&#125;\nbean解析\n还是分部分说明(parseBeanDefinitionElement)。\n首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。\n123456789String className = null;if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;    className = ele.getAttribute(CLASS_ATTRIBUTE).trim();&#125;String parent = null;if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;    parent = ele.getAttribute(PARENT_ATTRIBUTE);&#125;AbstractBeanDefinition bd = createBeanDefinition(className, parent);\nBeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition:\n1234567891011121314public static AbstractBeanDefinition createBeanDefinition(        String parentName, String className, ClassLoader classLoader) &#123;    GenericBeanDefinition bd = new GenericBeanDefinition();    bd.setParentName(parentName);    if (className != null) &#123;        if (classLoader != null) &#123;            bd.setBeanClass(ClassUtils.forName(className, classLoader));        &#125;        else &#123;            bd.setBeanClassName(className);        &#125;    &#125;    return bd;&#125;\n之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中:\n1parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n之后解析bean的decription子元素:\n123&lt;bean id=\"b\" name=\"one, two\" class=\"base.SimpleBean\"&gt;    &lt;description&gt;SimpleBean&lt;/description&gt;&lt;/bean&gt;\n就仅仅是个描述。\n然后是meta子元素的解析，meta元素在xml配置文件里是这样的:\n123&lt;bean id=\"b\" name=\"one, two\" class=\"base.SimpleBean\"&gt;    &lt;meta key=\"name\" value=\"skywalker\"/&gt;&lt;/bean&gt;\n注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码:\n12345678910111213141516public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) &#123;    NodeList nl = ele.getChildNodes();    for (int i = 0; i &lt; nl.getLength(); i++) &#123;        Node node = nl.item(i);        if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;            Element metaElement = (Element) node;            String key = metaElement.getAttribute(KEY_ATTRIBUTE);            String value = metaElement.getAttribute(VALUE_ATTRIBUTE);             //就是一个key, value的载体，无他            BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);             //sourceExtractor默认是NullSourceExtractor，返回的是空            attribute.setSource(extractSource(metaElement));            attributeAccessor.addMetadataAttribute(attribute);        &#125;    &#125;&#125;\nAbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。\nlookup-method解析：\n此标签的作用在于当一个bean的某个方法被设置为lookup-method后，每次调用此方法时，都会返回一个新的指定bean的对象。用法示例:\n12345&lt;bean id=\"apple\" class=\"cn.com.willchen.test.di.Apple\" scope=\"prototype\"/&gt;&lt;!--水果盘--&gt;&lt;bean id=\"fruitPlate\" class=\"cn.com.willchen.test.di.FruitPlate\"&gt;    &lt;lookup-method name=\"getFruit\" bean=\"apple\"/&gt;&lt;/bean&gt;\n数据保存在Set中，对应的类是MethodOverrides。可以参考:\nSpring - lookup-method方式实现依赖注入\nreplace-mothod解析:\n此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。\n配置文件示例:\n123456&lt;bean name=\"replacer\" class=\"springroad.deomo.chap4.MethodReplace\" /&gt;  &lt;bean name=\"testBean\" class=\"springroad.deomo.chap4.LookupMethodBean\"&gt;    &lt;replaced-method name=\"test\" replacer=\"replacer\"&gt;        &lt;arg-type match=\"String\" /&gt;    &lt;/replaced-method&gt;  &lt;/bean&gt;\narg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: SPRING.NET 1.3.2 学习20–方法注入之替换方法注入\n解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList专门用于保存arg-type。\n构造参数(constructor-arg)解析:\n作用一目了然，使用示例:\n12345&lt;bean class=\"base.SimpleBean\"&gt;    &lt;constructor-arg&gt;        &lt;value type=\"java.lang.String\"&gt;Cat&lt;/value&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;\ntype一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以Map&lt;Integer, ValueHolder&gt;的形式保存，反之，以List的形式保存。\nproperty解析:\n非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例:\n123&lt;bean class=\"base.SimpleBean\"&gt;    &lt;property name=\"name\" value=\"skywalker\" /&gt;&lt;/bean&gt;\nvalue和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。\nqualifier解析:\n配置示例:\n1234567891011&lt;bean class=\"base.Student\"&gt;    &lt;property name=\"name\" value=\"skywalker\"&gt;&lt;/property&gt;    &lt;property name=\"age\" value=\"12\"&gt;&lt;/property&gt;    &lt;qualifier type=\"org.springframework.beans.factory.annotation.Qualifier\" value=\"student\" /&gt;&lt;/bean&gt;\t&lt;bean class=\"base.Student\"&gt;    &lt;property name=\"name\" value=\"seaswalker\"&gt;&lt;/property&gt;    &lt;property name=\"age\" value=\"15\"&gt;&lt;/property&gt;    &lt;qualifier value=\"student_2\"&gt;&lt;/qualifier&gt;&lt;/bean&gt;&lt;bean class=\"base.SimpleBean\" /&gt;\nSimpleBean部分源码:\n123@Autowired@Qualifier(\"student\")private Student student;\n此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如:\n123&lt;qualifier type=\"org.springframework.beans.factory.annotation.Qualifier\" value=\"student\"&gt;    &lt;attribute key=\"id\" value=\"1\"/&gt;&lt;/qualifier&gt;\n貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。\nBean装饰\n这部分是针对其它schema的属性以及子节点，比如:\n123&lt;bean class=\"base.Student\" primary=\"true\"&gt;    &lt;context:property-override /&gt;&lt;/bean&gt;\n没见过这种用法，留个坑。\nBean注册\nBeanDefinitionReaderUtils.registerBeanDefinition:\n12345678910111213public static void registerBeanDefinition(    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) &#123;    // Register bean definition under primary name.    String beanName = definitionHolder.getBeanName();    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());    // Register aliases for bean name, if any.    String[] aliases = definitionHolder.getAliases();    if (aliases != null) &#123;        for (String alias : aliases) &#123;            registry.registerAlias(beanName, alias);        &#125;    &#125;&#125;\nregistry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事:\n12345@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) &#123;    this.beanDefinitionMap.put(beanName, beanDefinition);    this.beanDefinitionNames.add(beanName);&#125;\n一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。\nComponentRegistered事件触发:\n默认是个空实现，前面说过了。\nBeanDefiniton数据结构\nBeanDefiniton数据结构如下图:\n\nbeans\nbeans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。\n其它命名空间解析\n入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions-&gt;BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空):\n12345public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123;    String namespaceUri = getNamespaceURI(ele);    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125;\nNamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。\n其resolve方法:\n1234567891011121314151617@Overridepublic NamespaceHandler resolve(String namespaceUri) &#123;    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();    Object handlerOrClassName = handlerMappings.get(namespaceUri);    if (handlerOrClassName == null) &#123;        return null;    &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123;        return (NamespaceHandler) handlerOrClassName;    &#125; else &#123;        String className = (String) handlerOrClassName;        Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader);        NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);        namespaceHandler.init();        handlerMappings.put(namespaceUri, namespaceHandler);        return namespaceHandler;    &#125;&#125;\n容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回。\nNamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例:\n12345http\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandlerhttp\\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandlerhttp\\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandlerhttp\\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandlerhttp\\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler\nNamespaceHandler继承体系\n\ninit\nresolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。此接口用以解析顶层(beans下)的非默认命名空间元素，比如&lt;context:annotation-config /&gt;。\n所以这样逻辑就很容易理解了: 每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程。\n此部分较为重要，所以重新开始大纲。\nBeanFactory数据结构\nBeanDefinition在BeanFactory中的主要数据结构如下图:\n\nprepareBeanFactory\n此方法负责对BeanFactory进行一些特征的设置工作，&quot;特征&quot;包含这么几个方面:\nBeanExpressionResolver\n此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法:\n1Object evaluate(String value, BeanExpressionContext evalContext)\nprepareBeanFactory将一个此对象放入BeanFactory:\n1beanFactory.setBeanExpressionResolver(new \t\t\t\t\t\t \t\t\tStandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\nStandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图:\n\n这便是Spring3.0开始出现的Spel表达式的解释器。\nPropertyEditorRegistrar\n此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法:\n1registerCustomEditors(PropertyEditorRegistry registry)\n实现也只有一个: ResourceEditorRegistrar。\n在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。\nprepareBeanFactory:\n1beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\nBeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。\n我们有两种方式可以添加自定义PropertyEditor:\n\n\n通过context.getBeanFactory().registerCustomEditor\n\n\n通过Spring配置文件:\n1234567&lt;bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\"&gt;  &lt;property name=\"customEditors\"&gt;          &lt;map&gt;              &lt;entry key=\"base.Cat\" value=\"base.CatEditor\" /&gt;       &lt;/map&gt;  &lt;/property&gt;&lt;/bean&gt;\n\n\n参考: 深入理解JavaBean(2)：属性编辑器PropertyEditor\n环境注入\n在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory:\n1beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\nApplicationContextAwareProcessor核心的invokeAwareInterfaces方法:\n1234567891011private void invokeAwareInterfaces(Object bean) &#123;    if (bean instanceof Aware) &#123;        if (bean instanceof EnvironmentAware) &#123;            ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());        &#125;        if (bean instanceof EmbeddedValueResolverAware) &#123;            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);        &#125;        //....    &#125;&#125;\n依赖解析忽略\n此部分设置哪些接口在进行依赖注入的时候应该被忽略:\n12345beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);beanFactory.ignoreDependencyInterface(MessageSourceAware.class);beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\nbean伪装\n有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下:\n1234beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);beanFactory.registerResolvableDependency(ResourceLoader.class, this);beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n伪装关系保存在一个Map&lt;Class&lt;?&gt;, Object&gt;里。\nLoadTimeWeaver\n如果配置了此bean，那么：\n12345if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;    beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));    // Set a temporary ClassLoader for type matching.    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));&#125;\n这个东西具体是干什么的在后面context:load-time-weaver中说明。\n注册环境\n源码:\n12345678910if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());&#125;if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());&#125;if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().        getSystemEnvironment());&#125;\ncontainsLocalBean特殊之处在于不会去父BeanFactory寻找。\npostProcessBeanFactory\n此方法允许子类在所有的bean尚未初始化之前注册BeanPostProcessor。空实现且没有子类覆盖。\ninvokeBeanFactoryPostProcessors\nBeanFactoryPostProcessor接口允许我们在bean正是初始化之前改变其值。此接口只有一个方法:\n1void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory);\n有两种方式可以向Spring添加此对象:\n\n\n通过代码的方式:\n1context.addBeanFactoryPostProcessor\n\n\n通过xml配置的方式:\n1&lt;bean class=\"base.SimpleBeanFactoryPostProcessor\" /&gt;\n\n\n注意此时尚未进行bean的初始化工作，初始化是在后面的finishBeanFactoryInitialization进行的，所以在BeanFactoryPostProcessor对象中获取bean会导致提前初始化。\n此方法的关键源码:\n1234protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory,        getBeanFactoryPostProcessors());&#125;\ngetBeanFactoryPostProcessors获取的就是AbstractApplicationContext的成员beanFactoryPostProcessors(ArrayList)，但是很有意思，只有通过context.addBeanFactoryPostProcessor这种方式添加的才会出现在这个List里，所以对于xml配置方式，此List其实没有任何元素。玄机就在PostProcessorRegistrationDelegate里。\n核心思想就是使用BeanFactory的getBeanNamesForType方法获取相应的BeanDefinition的name数组，之后逐一调用getBean方法获取到bean(初始化)，getBean方法后面再说。\n注意此处有一个优先级的概念，如果你的BeanFactoryPostProcessor同时实现了Ordered或者是PriorityOrdered接口，那么会被首先执行。\nBeanPostProcessor注册\n此部分实质上是在BeanDefinitions中寻找BeanPostProcessor，之后调用BeanFactory.addBeanPostProcessor方法保存在一个List中，注意添加时仍然有优先级的概念，优先级高的在前面。\nMessageSource\n此接口用以支持Spring国际化。继承体系如下:\n\nAbstractApplicationContext的initMessageSource()方法就是在BeanFactory中查找MessageSource的bean，如果配置了此bean，那么调用getBean方法完成其初始化并将其保存在AbstractApplicationContext内部messageSource成员变量中，用以处理ApplicationContext的getMessage调用，因为从继承体系上来看，ApplicationContext是MessageSource的子类，此处是委托模式的体现。如果没有配置此bean，那么初始化一个DelegatingMessageSource对象，此类是一个空实现，同样用以处理getMessage调用请求。\n参考: 学习Spring必学的Java基础知识(8)----国际化信息\n事件驱动\n此接口代表了Spring的事件驱动(监听器)模式。一个事件驱动包含三部分:\n事件\njava的所有事件对象一般都是java.util.EventObject的子类，Spring的整个继承体系如下:\n\n发布者\nApplicationEventPublisher\n\n一目了然。\nApplicationEventMulticaster\nApplicationEventPublisher实际上正是将请求委托给ApplicationEventMulticaster来实现的。其继承体系:\n\n监听器\n所有的监听器是jdk EventListener的子类，这是一个mark接口。继承体系:\n\n可以看出SmartApplicationListener和GenericApplicationListener是高度相似的，都提供了事件类型检测和顺序机制，而后者是从Spring4.2加入的，Spring官方文档推荐使用后者代替前者。\n初始化\n前面说过ApplicationEventPublisher是通过委托给ApplicationEventMulticaster实现的，所以refresh方法中完成的是对ApplicationEventMulticaster的初始化:\n12// Initialize event multicaster for this context.initApplicationEventMulticaster();\ninitApplicationEventMulticaster则首先在BeanFactory中寻找ApplicationEventMulticaster的bean，如果找到，那么调用getBean方法将其初始化，如果找不到那么使用SimpleApplicationEventMulticaster。\n事件发布\nAbstractApplicationContext.publishEvent核心代码:\n123protected void publishEvent(Object event, ResolvableType eventType) &#123;    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);&#125;\nSimpleApplicationEventMulticaster.multicastEvent:\n1234567891011121314151617@Overridepublic void multicastEvent(final ApplicationEvent event, ResolvableType eventType) &#123;    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));    for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;        Executor executor = getTaskExecutor();        if (executor != null) &#123;            executor.execute(new Runnable() &#123;                @Override                public void run() &#123;                    invokeListener(listener, event);                &#125;            &#125;);        &#125; else &#123;            invokeListener(listener, event);        &#125;    &#125;&#125;\n监听器获取\n获取当然还是通过beanFactory的getBean来完成的，值得注意的是Spring在此处使用了缓存(ConcurrentHashMap)来加速查找的过程。\n同步/异步\n可以看出，如果executor不为空，那么监听器的执行实际上是异步的。那么如何配置同步/异步呢?\n全局\n1234&lt;task:executor id=\"multicasterExecutor\" pool-size=\"3\"/&gt;&lt;bean class=\"org.springframework.context.event.SimpleApplicationEventMulticaster\"&gt;    &lt;property name=\"taskExecutor\" ref=\"multicasterExecutor\"&gt;&lt;/property&gt;&lt;/bean&gt;\ntask schema是Spring从3.0开始加入的，使我们可以不再依赖于Quartz实现定时任务，源码在org.springframework.core.task包下，使用需要引入schema：\n12xmlns:task=\"http://www.springframework.org/schema/task\"xsi:schemaLocation=\"http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd\"\n可以参考: Spring定时任务的几种实现\n注解\n开启注解支持:\n12345678&lt;!-- 开启@AspectJ AOP代理 --&gt;  &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt;  &lt;!-- 任务调度器 --&gt;  &lt;task:scheduler id=\"scheduler\" pool-size=\"10\"/&gt;  &lt;!-- 任务执行器 --&gt;  &lt;task:executor id=\"executor\" pool-size=\"10\"/&gt;  &lt;!--开启注解调度支持 @Async @Scheduled--&gt;  &lt;task:annotation-driven executor=\"executor\" scheduler=\"scheduler\" proxy-target-class=\"true\"/&gt;\n在代码中使用示例:\n12345678@Component  public class EmailRegisterListener implements ApplicationListener&lt;RegisterEvent&gt; &#123;      @Async      @Override      public void onApplicationEvent(final RegisterEvent event) &#123;          System.out.println(\"注册成功，发送确认邮件给：\" + ((User)event.getSource()).getUsername());      &#125;  &#125;\n参考: 详解Spring事件驱动模型\nonRefresh\n这又是一个模版方法，允许子类在进行bean初始化之前进行一些定制操作。默认空实现。\nApplicationListener注册\nregisterListeners方法干的，没什么好说的。\nsingleton初始化\nfinishBeanFactoryInitialization：\n123456789101112131415161718192021222324protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;        beanFactory.setConversionService(                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));    &#125;    if (!beanFactory.hasEmbeddedValueResolver()) &#123;        beanFactory.addEmbeddedValueResolver(new StringValueResolver() &#123;            @Override            public String resolveStringValue(String strVal) &#123;                return getEnvironment().resolvePlaceholders(strVal);            &#125;        &#125;);    &#125;    String[] weaverAwareNames = beanFactory.getBeanNamesForType        (LoadTimeWeaverAware.class, false, false);    for (String weaverAwareName : weaverAwareNames) &#123;        getBean(weaverAwareName);    &#125;    // Allow for caching all bean definition metadata, not expecting further changes.    beanFactory.freezeConfiguration();    // Instantiate all remaining (non-lazy-init) singletons.    beanFactory.preInstantiateSingletons();&#125;\n分部分说明。\nConversionService\n此接口用于类型之间的转换，在Spring里其实就是把配置文件中的String转为其它类型，从3.0开始出现，目的和jdk的PropertyEditor接口是一样的，参考ConfigurableBeanFactory.setConversionService注释:\n\n\nSpecify a Spring 3.0 ConversionService to use for converting\nproperty values, as an alternative to JavaBeans PropertyEditors.\n@since 3.0\n\n\nStringValueResolver\n用于解析注解的值。接口只定义了一个方法:\n1String resolveStringValue(String strVal);\nLoadTimeWeaverAware\n实现了此接口的bean可以得到LoadTimeWeaver，此处仅仅初始化。\n初始化\nDefaultListableBeanFactory.preInstantiateSingletons:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overridepublic void preInstantiateSingletons() throws BeansException &#123;    List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);    for (String beanName : beanNames) &#123;        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);        if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;            if (isFactoryBean(beanName)) &#123;                final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX                     + beanName);                boolean isEagerInit;                if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;                    isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;                        @Override                        public Boolean run() &#123;                            return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();                        &#125;                    &#125;, getAccessControlContext());                &#125;                else &#123;                    isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;                            ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());                &#125;                if (isEagerInit) &#123;                    getBean(beanName);                &#125;            &#125;            else &#123;                getBean(beanName);            &#125;        &#125;    &#125;    // Trigger post-initialization callback for all applicable beans...    for (String beanName : beanNames) &#123;        Object singletonInstance = getSingleton(beanName);        if (singletonInstance instanceof SmartInitializingSingleton) &#123;            final SmartInitializingSingleton smartSingleton =                 (SmartInitializingSingleton) singletonInstance;            if (System.getSecurityManager() != null) &#123;                AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;                    @Override                    public Object run() &#123;                        smartSingleton.afterSingletonsInstantiated();                        return null;                    &#125;                &#125;, getAccessControlContext());            &#125;            else &#123;                smartSingleton.afterSingletonsInstantiated();            &#125;        &#125;    &#125;&#125;\n首先进行Singleton的初始化，其中如果bean是FactoryBean类型(注意，只定义了factory-method属性的普通bean并不是FactoryBean)，并且还是SmartFactoryBean类型，那么需要判断是否需要eagerInit(isEagerInit是此接口定义的方法)。\ngetBean\n这里便是bean初始化的核心逻辑。源码比较复杂，分开说。以getBean(String name)为例。AbstractBeanFactory.getBean:\n1234@Overridepublic Object getBean(String name) throws BeansException &#123;    return doGetBean(name, null, null, false);&#125;\n第二个参数表示bean的Class类型，第三个表示创建bean需要的参数，最后一个表示不需要进行类型检查。\nbeanName转化\n1final String beanName = transformedBeanName(name);\n这里是将FactoryBean的前缀去掉以及将别名转为真实的名字。\n手动注册bean检测\n前面注册环境一节说过，Spring其实手动注册了一些单例bean。这一步就是检测是不是这些bean。如果是，那么再检测是不是工厂bean，如果是返回其工厂方法返回的实例，如果不是返回bean本身。\n1234Object sharedInstance = getSingleton(beanName);if (sharedInstance != null &amp;&amp; args == null) &#123;    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);&#125;\n检查父容器\n如果父容器存在并且存在此bean定义，那么交由其父容器初始化:\n12345678910111213BeanFactory parentBeanFactory = getParentBeanFactory();if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;    // Not found -&gt; check parent.    //此方法其实是做了前面beanName转化的逆操作，因为父容器同样会进行转化操作    String nameToLookup = originalBeanName(name);    if (args != null) &#123;        // Delegation to parent with explicit args.        return (T) parentBeanFactory.getBean(nameToLookup, args);    &#125; else &#123;        // No args -&gt; delegate to standard getBean method.        return parentBeanFactory.getBean(nameToLookup, requiredType);    &#125;&#125;\n依赖初始化\nbean可以由depends-on属性配置依赖的bean。Spring会首先初始化依赖的bean。\n123456789101112String[] dependsOn = mbd.getDependsOn();if (dependsOn != null) &#123;    for (String dependsOnBean : dependsOn) &#123;         //检测是否存在循环依赖        if (isDependent(beanName, dependsOnBean)) &#123;            throw new BeanCreationException(mbd.getResourceDescription(), beanName,            \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dependsOnBean + \"'\");        &#125;        registerDependentBean(dependsOnBean, beanName);        getBean(dependsOnBean);    &#125;&#125;\nregisterDependentBean进行了依赖关系的注册，这么做的原因是Spring在即进行bean销毁的时候会首先销毁被依赖的bean。依赖关系的保存是通过一个ConcurrentHashMap&lt;String, Set&gt;完成的，key是bean的真实名字。\nSingleton初始化\n虽然这里大纲是Singleton初始化，但是getBean方法本身是包括所有scope的初始化，在这里一次说明了。\n123456789if (mbd.isSingleton()) &#123;    sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;        @Override        public Object getObject() throws BeansException &#123;            return createBean(beanName, mbd, args);        &#125;    &#125;);    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125;\ngetSingleton方法\n是否存在\n首先会检测是否已经存在，如果存在，直接返回:\n123synchronized (this.singletonObjects) &#123;    Object singletonObject = this.singletonObjects.get(beanName);&#125;\n所有的单例bean都保存在这样的数据结构中: ConcurrentHashMap&lt;String, Object&gt;。\nbean创建\n源码位于AbstractAutowireCapableBeanFactory.createBean，主要分为几个部分:\nlookup-method检测\n此部分用于检测lookup-method标签配置的方法是否存在:\n12RootBeanDefinition mbdToUse = mbd;mbdToUse.prepareMethodOverrides();\nprepareMethodOverrides:\n123456789101112public void prepareMethodOverrides() throws BeanDefinitionValidationException &#123;    // Check that lookup methods exists.    MethodOverrides methodOverrides = getMethodOverrides();    if (!methodOverrides.isEmpty()) &#123;        Set&lt;MethodOverride&gt; overrides = methodOverrides.getOverrides();        synchronized (overrides) &#123;            for (MethodOverride mo : overrides) &#123;                prepareMethodOverride(mo);            &#125;        &#125;    &#125;&#125;\nprepareMethodOverride:\n1234567891011protected void prepareMethodOverride(MethodOverride mo)  &#123;    int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());    if (count == 0) &#123;        throw new BeanDefinitionValidationException(                \"Invalid method override: no method with name '\" + mo.getMethodName() +                \"' on class [\" + getBeanClassName() + \"]\");    &#125; else if (count == 1) &#123;        // Mark override as not overloaded, to avoid the overhead of arg type checking.        mo.setOverloaded(false);    &#125;&#125;\nInstantiationAwareBeanPostProcessor触发\n在这里触发的是其postProcessBeforeInitialization和postProcessAfterInstantiation方法。\n123456Object bean = resolveBeforeInstantiation(beanName, mbdToUse);if (bean != null) &#123;    return bean;&#125;Object beanInstance = doCreateBean(beanName, mbdToUse, args);return beanInstance;\n继续:\n1234567891011121314151617protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123;    Object bean = null;    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;        // Make sure bean class is actually resolved at this point.        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);            if (targetType != null) &#123;                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);                if (bean != null) &#123;                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);                &#125;            &#125;        &#125;        mbd.beforeInstantiationResolved = (bean != null);    &#125;    return bean;&#125;\n从这里可以看出，如果InstantiationAwareBeanPostProcessor返回的不是空，那么将不会继续执行剩下的Spring初始化流程，此接口用于初始化自定义的bean，主要是在Spring内部使用。\ndoCreateBean\n同样分为几部分。\n创建(createBeanInstance)\n关键代码:\n1234BeanWrapper instanceWrapper = null;if (instanceWrapper == null) &#123;    instanceWrapper = createBeanInstance(beanName, mbd, args);&#125;\ncreateBeanInstance的创建过程又分为以下几种情况:\n\n\n工厂bean:\n调用instantiateUsingFactoryMethod方法:\n1234protected BeanWrapper instantiateUsingFactoryMethod(  String beanName, RootBeanDefinition mbd, Object[] explicitArgs) &#123;  return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);&#125;\n注意，此处的工厂bean指的是配置了factory-bean/factory-method属性的bean，不是实现了FacrotyBean接口的bean。如果没有配置factory-bean属性，那么factory-method指向的方法必须是静态的。此方法主要做了这么几件事:\n\n\n初始化一个BeanWrapperImpl对象。\n\n\n根据设置的参数列表使用反射的方法寻找相应的方法对象。\n\n\nInstantiationStrategy:\nbean的初始化在此处又抽成了策略模式，类图:\n\ninstantiateUsingFactoryMethod部分源码:\n12beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(    mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\ngetInstantiationStrategy返回的是CglibSubclassingInstantiationStrategy对象。此处instantiate实现也很简单，就是调用工厂方法的Method对象反射调用其invoke即可得到对象，SimpleInstantiationStrategy.\ninstantiate核心源码:\n12345@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner,    Object factoryBean, final Method factoryMethod, Object... args) &#123;    return factoryMethod.invoke(factoryBean, args);&#125;\n\n\n\n\n构造器自动装配\ncreateBeanInstance部分源码:\n12345678// Need to determine the constructor...Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);if (ctors != null ||  mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||    //配置了&lt;constructor-arg&gt;子元素  mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;  return autowireConstructor(beanName, mbd, ctors, args);&#125;\ndetermineConstructorsFromBeanPostProcessors源码:\n123456789101112131415protected Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(Class&lt;?&gt; beanClass, String beanName) &#123;  if (beanClass != null &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;      for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;          if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123;              SmartInstantiationAwareBeanPostProcessor ibp =                   (SmartInstantiationAwareBeanPostProcessor) bp;              Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);              if (ctors != null) &#123;                  return ctors;              &#125;          &#125;      &#125;  &#125;  return null;&#125;\n可见是由SmartInstantiationAwareBeanPostProcessor决定的，默认是没有配置这种东西的。\n之后就是判断bean的自动装配模式，可以通过如下方式配置:\n1&lt;bean id=\"student\" class=\"base.Student\" primary=\"true\" autowire=\"default\" /&gt;\nautowire共有以下几种选项:\n\nno: 默认的，不进行自动装配。在这种情况下，只能通过ref方式引用其它bean。\nbyName: 根据bean里面属性的名字在BeanFactory中进行查找并装配。\nbyType: 按类型。\nconstructor: 以byType的方式查找bean的构造参数列表。\ndefault: 由父bean决定。\n\n参考: Spring - bean的autowire属性(自动装配)\nautowireConstructor调用的是ConstructorResolver.autowireConstructor，此方法主要做了两件事:\n\n\n得到合适的构造器对象。\n\n\n根据构造器参数的类型去BeanFactory查找相应的bean:\n入口方法在ConstructorResolver.resolveAutowiredArgument:\n1234567protected Object resolveAutowiredArgument(        MethodParameter param, String beanName, Set&lt;String&gt; autowiredBeanNames,         TypeConverter typeConverter) &#123;    return this.beanFactory.resolveDependency(            new DependencyDescriptor(param, true), beanName,             autowiredBeanNames, typeConverter);&#125;\n\n\n最终调用的还是CglibSubclassingInstantiationStrategy.instantiate方法，关键源码:\n12345678910@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner,      final Constructor&lt;?&gt; ctor, Object... args) &#123;  if (bd.getMethodOverrides().isEmpty()) &#123;           //反射调用      return BeanUtils.instantiateClass(ctor, args);  &#125; else &#123;      return instantiateWithMethodInjection(bd, beanName, owner, ctor, args);  &#125;&#125;\n可以看出，如果配置了lookup-method标签，得到的实际上是用Cglib生成的目标类的代理子类。\nCglibSubclassingInstantiationStrategy.instantiateWithMethodInjection:\n12345@Overrideprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, String beanName, BeanFactory \towner,Constructor&lt;?&gt; ctor, Object... args) &#123;  // Must generate CGLIB subclass...  return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);&#125;\n\n\n默认构造器\n一行代码，很简单:\n12// No special handling: simply use no-arg constructor.return instantiateBean(beanName, mbd);\n\n\nMergedBeanDefinitionPostProcessor\n触发源码:\n123456synchronized (mbd.postProcessingLock) &#123;    if (!mbd.postProcessed) &#123;        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);        mbd.postProcessed = true;    &#125;&#125;\n此接口也是Spring内部使用的，不管它了。\n属性解析\n入口方法: AbstractAutowireCapableBeanFactory.populateBean，它的作用是: 根据autowire类型进行autowire by name，by type 或者是直接进行设置，简略后的源码:\n1234567891011121314151617181920212223protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;    //所有&lt;property&gt;的值    PropertyValues pvs = mbd.getPropertyValues();    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);        // Add property values based on autowire by name if applicable.        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;            autowireByName(beanName, mbd, bw, newPvs);        &#125;        // Add property values based on autowire by type if applicable.        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;            autowireByType(beanName, mbd, bw, newPvs);        &#125;        pvs = newPvs;    &#125;    //设值    applyPropertyValues(beanName, mbd, bw, pvs);&#125;\nautowireByName源码:\n12345678910111213protected void autowireByName(        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;    //返回所有引用(ref=\"XXX\")的bean名称    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);    for (String propertyName : propertyNames) &#123;        if (containsBean(propertyName)) &#123;             //从BeanFactory获取            Object bean = getBean(propertyName);            pvs.add(propertyName, bean);            registerDependentBean(propertyName, beanName);        &#125;    &#125;&#125;\nautowireByType也是同样的套路，所以可以得出结论: autowireByName和autowireByType方法只是先获取到引用的bean，真正的设值是在applyPropertyValues中进行的。\n属性设置\nSpring判断一个属性可不可以被设置(存不存在)是通过java bean的内省操作来完成的，也就是说，属性可以被设置的条件是此属性拥有public的setter方法，并且注入时的属性名应该是setter的名字。\n初始化\n此处的初始化指的是bean已经构造完成，执行诸如调用其init方法的操作。相关源码:\n12345678// Initialize the bean instance.Object exposedObject = bean;try &#123;    populateBean(beanName, mbd, instanceWrapper);    if (exposedObject != null) &#123;        exposedObject = initializeBean(beanName, exposedObject, mbd);    &#125;&#125;\ninitializeBean:\n1234567891011121314151617181920212223242526protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;    if (System.getSecurityManager() != null) &#123;        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;            @Override            public Object run() &#123;                invokeAwareMethods(beanName, bean);                return null;            &#125;        &#125;, getAccessControlContext());    &#125;    else &#123;        invokeAwareMethods(beanName, bean);    &#125;    Object wrappedBean = bean;    if (mbd == null || !mbd.isSynthetic()) &#123;        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    &#125;    invokeInitMethods(beanName, wrappedBean, mbd);    if (mbd == null || !mbd.isSynthetic()) &#123;        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    &#125;    return wrappedBean;&#125;\n主要的操作步骤一目了然。\n\n\nAware方法触发:\n我们的bean有可能实现了一些XXXAware接口，此处就是负责调用它们:\n12345678910111213private void invokeAwareMethods(final String beanName, final Object bean) &#123;  if (bean instanceof Aware) &#123;      if (bean instanceof BeanNameAware) &#123;          ((BeanNameAware) bean).setBeanName(beanName);      &#125;      if (bean instanceof BeanClassLoaderAware) &#123;          ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());      &#125;      if (bean instanceof BeanFactoryAware) &#123;          ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);      &#125;  &#125;&#125;\n\n\nBeanPostProcessor触发，没什么好说的\n\n\n调用init方法:\n在XML配置中，bean可以有一个init-method属性来指定初始化时调用的方法。从原理来说，其实就是一个反射调用。不过注意这里有一个InitializingBean的概念。\n此接口只有一个方法：\n1void afterPropertiesSet() throws Exception;\n如果我们的bean实现了此接口，那么此方法会首先被调用。此接口的意义在于: 当此bean的所有属性都被设置(注入)后，给bean一个利用现有属性重新组织或是检查属性的机会。感觉和init方法有些冲突，不过此接口在Spring被广泛使用。\n\n\ngetObjectForBeanInstance\n位于AbstractBeanFactory，此方法的目的在于如果bean是FactoryBean，那么返回其工厂方法创建的bean，而不是自身。\nPrototype初始化\nAbstractBeanFactory.doGetBean相关源码:\n123456789101112else if (mbd.isPrototype()) &#123;    // It's a prototype -&gt; create a new instance.    Object prototypeInstance = null;    try &#123;        beforePrototypeCreation(beanName);        prototypeInstance = createBean(beanName, mbd, args);    &#125;    finally &#123;        afterPrototypeCreation(beanName);    &#125;    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125;\nbeforePrototypeCreation\n此方法用于确保在同一时刻只能有一个此bean在初始化。\ncreateBean\n和单例的是一样的，不在赘述。\nafterPrototypeCreation\n和beforePrototypeCreation对应的，你懂的。\n总结\n可以看出，初始化其实和单例是一样的，只不过单例多了一个是否已经存在的检查。\n其它Scope初始化\n其它就指的是request、session。此部分源码:\n1234567891011121314151617181920else &#123;    String scopeName = mbd.getScope();    final Scope scope = this.scopes.get(scopeName);    if (scope == null) &#123;        throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");    &#125;    Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;        @Override        public Object getObject() throws BeansException &#123;            beforePrototypeCreation(beanName);            try &#123;                return createBean(beanName, mbd, args);            &#125;            finally &#123;                afterPrototypeCreation(beanName);            &#125;        &#125;    &#125;);    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);&#125;\nscopes是一个LinkedHashMap&lt;String, Scope&gt;，可以调用 ConfigurableBeanFactory定义的registerScope方法注册其值。\nScope接口继承体系:\n\n根据socpe.get的注释，此方法如果找到了叫做beanName的bean，那么返回，如果没有，将调用ObjectFactory创建之。Scope的实现参考类图。\n","plink":"http://yoursite.com/2020/12/04/Spring/"},{"title":"my new post","date":"2020-04-23T07:24:34.000Z","date_formatted":{"ll":"Apr 23, 2020","L":"04/23/2020","MM-DD":"04-23"},"updated":"2020-04-23T07:24:34.367Z","content":"","plink":"http://yoursite.com/2020/04/23/my-new-post/"},{"title":"Hello World","date":"2020-04-23T06:25:00.809Z","date_formatted":{"ll":"Apr 23, 2020","L":"04/23/2020","MM-DD":"04-23"},"updated":"2020-04-23T06:25:00.809Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n1$ hexo new \"My New Post\"\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"http://yoursite.com/2020/04/23/hello-world/"}]